# -*- coding: utf-8 -*-
"""Untitled (2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_AOyczeR3MeNCHzedIKHkOOtu0zKZLxh
"""

class complejo: #se define la clase para números complejos
    def __init__(self, real, imaginario): #Los atributos de un numero real son su parte real y su parte imaginaria
        self.real = real
        self.imaginario = imaginario
        # cada self se define
    def suma(self,other): #Se propone la función suma
        sum_real = self.real+other.real # Por definición se suman las partes reales por aparte
        sum_im = self.imaginario+other.imaginario # Y las partes imaginarias por aparte
        z = complejo(sum_real, sum_im) # Se puede retornar con el formato de z o hacerlo como str
        return (f"{sum_real}+{sum_im}i")
    def resta(self,other): #Se propone la función resta
        resta_real = self.real-other.real 
        resta_im = self.imaginario-other.imaginario
        #Pasa lo mismo que en la suma pero con -
        return (f"{resta_real}+{resta_im}i")
    def producto_(self,other): #Se propone la función producto_ como una funcion de transcición para invocarla en la función división
        real1 = self.real*other.real
        im1 = self.real*other.imaginario
        im2 = self.imaginario*other.real
        real2 = self.imaginario*other.imaginario*-1
        real = real1 + real2
        im = im1 + im2
        return complejo(real,im)
    def producto(self,other): #Se propone la función de multiplicación
        real1 = self.real*other.real 
        im1 = self.real*other.imaginario
        im2 = self.imaginario*other.real
        real2 = self.imaginario*other.imaginario*-1
        #Por definición se hace distributiva de 4 terminos
        real = real1 + real2
        im = im1 + im2
        #Luego se hace la suma de reales e imaginarios
        return (f"{real}+{im}i")
    def division(self,other): #Se propone la función division
        cosa = complejo(other.real, other.imaginario*-1) #Para hacer la operacion correcta se necesita el conjugado del divisor
        nominador = self.producto_(cosa) #se invoca la funcion producto para multiplicar el dividendo con el conjugado
        denominador = other.producto_(cosa) #Se invoca la funcion producto para multiplicar el divisor con su conjugado (queda sin parte imaginaria)
        real = nominador.real/denominador.real #se halla la parte real
        im = nominador.imaginario/denominador.real #se halla la parte imaginaria
        return (f"{real}+{im}")
    def norma (self): #Se propone la función norma
        operacion = ((self.real*self.real + self.imaginario*self.imaginario)**(1/2))# se have la operación por definición de norma
        return (f"{operacion}")
#Se proponen 4 numeros complejos para hacer dos ejemplos de cada una de las operaciones definidas dentro de la clase
z1 = complejo(1,2)
z2 = complejo(3,4)
z3 = complejo(5,6)
z4 = complejo(4,4)

z1.suma(z2)

z3.suma(z4)

z1.resta(z2)

z3.resta(z4)

z1.producto(z2)

z3.producto(z4)

z1.division(z2)

z3.division(z4)

z1.norma()

z2.norma()

